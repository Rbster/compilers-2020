-- Stack machine.

import List;
import World;
import State;
import Expr;
import Util;

-- Stack machine interpreter. Takes an SM-configuration and a program,
-- returns a final configuration
fun eval (c, insns) {
--  failure ("SM eval not implemented\n");
  fun evalInsn (c, insn) {
    printf("curr stack:  %s\n", c[0].string);
    printf("--->instr: %s\n", insn.string);
--    printf("BINOP -> %s\n", BINOP ("+").string);
--    printf("fun deepFl - %s\n", deepFlatten);
--    printf("curr stack:  %s\n", c[0].string);  
    case insn of
      BINOP (op) ->
        local l, r, result;
        r := c[0].hd;
        l := c[0].tl.hd;
        result := evalBinop (op, l, r);
--        c[0][1][0] := evalBinop (op, c[0][1][0], c[0][0]);
--        c[0] := c[0][1];
        [{result, c[0].tl.tl}.flatten, c[1], c[2]]
    | CONST (n)  ->
--        c[0] := {n, c[0]};
        [{n, c[0]}.flatten, c[1], c[2]]
    | READ ->
        local r; 
        r := readWorld(c[2]);
        [{r[0], c[0]}.flatten, c[1], r[1]]
    | WRITE ->
        [c[0].tl, c[1], writeWorld(c[0].hd, c[2])]
    | LD (x) ->
        [{c[1] (x), c[0]}.flatten, c[1], c[2]]
    | ST (x) ->
        [c[0].tl, c[1] <- [x, c[0].hd], c[2]]
    esac
  }

--  evalInsn (c, B);  -- doesnt work
  local flatInsns;
--  evalInsn (c, B);  -- works 
  flatInsns := deepFlatten (insns);
  printf("all instr: %s\n", flatInsns.string);
--  iter (evalInsn, flatInsns[0])
--  flatInsns := flatInsns[0];
  printf("first insn: %s\n", flatInsns.hd.string);
  printf("others insns: %s\n", flatInsns.tl.string);
  
  while flatInsns != {} do
    c := evalInsn (c, flatInsns.hd);
    flatInsns := flatInsns.tl
  od;
  c
}

-- Runs a stack machine for a given input and a given program, returns an output
public fun evalSM (input, insns) {
  eval ([{}, emptyState, createWorld (input)], insns)[2].getOutput
}

-- Compiles an expression into a stack machine code.
-- Takes an expression, returns a list (of, possibly, lists)
-- of stack machine instructions
fun compileExpr (expr) {
--  failure ("compileExpr not implemented\n")
  case expr of
    Const (n)        -> {CONST (n)}
  | Var (x)          -> {LD (x)}
  | Binop (op, l, r) -> {compileExpr (l), compileExpr (r), BINOP (op)}
  esac
}

-- Compiles a statement into a stack machine code.
-- Takes a statement, returns a list of stack machine
-- instructions.
public fun compileSM (stmt) {
--  failure ("compileSM not implemented\n")
  case stmt of
    Assn (x, e)  -> {compileExpr (e), ST (x)}
  | Read (x)     -> {READ, ST (x)}
  | Write (e)    -> {compileExpr (e), WRITE}
  | Seq (s1, s2) -> {compileSM(s1), compileSM(s2)}
  esac
}
